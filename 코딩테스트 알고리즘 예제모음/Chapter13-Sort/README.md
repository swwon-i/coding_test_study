# 13. 정렬
## 13-1 정렬 개념
정렬이란 사용자가 정의한 순서로 데이터를 나열하는 것을 말함
정의한 순서는 오름차순이나 내림차순일 수 도 있다.
### 정렬이 필요한 이유
정렬되면 중앙값 찾기 쉬움(중간이 중앙값이다)
### 삽입 정렬
(정렬된 영역) (키) (정렬되지 않은 영역)
### 삽입 정렬의 시간 복잡도
삽입 정렬의 시간 복잡도는 O(N^2)
최선의 경우 이미 정렬되어 있으면 N
### 병합 정렬
정렬되지 않은 영역을 쪼개서 각각의 영역을 정렬하고 이를 합치며 정렬
### 병합 정렬의 시간 복잡도
O(NlogN)
log2N번 나누기와 N번의 병합
### 힙정렬
힙이라는 자료구조를 사용해 정렬
#### 힙이란?
최대 힙은 부모 노드가 자식 노드보다 크고, 최소힙은 부모 노드가 자식 노드보다 작습니다.
#### 힙 정렬의 시간 복잡도
시간 복자보는 O(N*logN)
### 우선순위 큐
한꺼번에 우선순위 큐에 데이터 넣는법
vector<int> initialValues = {10, 30, 20, 5, 1};
priority_queue<int> pq(initialValues.begin(), initialValues.end());
### 위상 정렬
진입차수를 1씩 낮추면서 새롭게 진입차수가 0이 된 작업들을 해결하는 식으로 진행
진입차수가 0인 작업을 일단 전부 큐에넣고 하나씩 팝
해결이란 행위를 큐를 활용하여 구현
### 계수 정렬
빈도수

### **위상 정렬 (Topological Sorting)**
위상 정렬은 **방향 그래프(Directed Graph)**에서 **사이클이 없는 경우(DAG, Directed Acyclic Graph)** 정점들을 **위상 순서(Topological Order)**로 정렬하는 알고리즘입니다.  
즉, **어떤 작업들이 순서대로 수행되어야 할 때** 사용됩니다.

---

## **📌 어디에서 사용될까?**
### **1️⃣ 작업 스케줄링 (Task Scheduling)**
- 예를 들어, **어떤 작업이 완료된 후에만 다음 작업을 수행할 수 있을 때** 사용됩니다.
- **예시:** 과목 수강 순서 (선수 과목이 있어야 다음 과목을 들을 수 있음)

### **2️⃣ 소프트웨어 빌드 순서 결정**
- A 라이브러리가 있어야 B 라이브러리를 컴파일할 수 있다면, **올바른 빌드 순서를 결정**하는 데 사용됩니다.

### **3️⃣ 컴파일러에서 코드 의존성 분석**
- C++의 **헤더 파일 포함 순서 결정** 등에도 사용됩니다.

---

## **🔹 C++ 예제: 작업 스케줄링**
위상 정렬을 이용하여 **작업을 수행하는 올바른 순서를 찾는 예제**입니다.  
(예: 한 과목을 수강하려면 선수 과목을 먼저 들어야 한다고 가정)

```cpp
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

// 위상 정렬 함수
vector<int> topologicalSort(int numCourses, vector<vector<int>> &prerequisites) {
    vector<vector<int>> graph(numCourses);  // 그래프 (인접 리스트)
    vector<int> inDegree(numCourses, 0);    // 진입 차수 배열
    vector<int> result;                     // 위상 정렬 결과

    // 그래프 구성 및 진입 차수 계산
    for (auto &edge : prerequisites) {
        int to = edge[0];   // 현재 과목
        int from = edge[1]; // 선수 과목
        graph[from].push_back(to);
        inDegree[to]++;
    }

    // 진입 차수가 0인 노드를 큐에 넣음 (즉, 선수 과목이 없는 과목부터 시작)
    queue<int> q;
    for (int i = 0; i < numCourses; i++) {
        if (inDegree[i] == 0) {
            q.push(i);
        }
    }

    // 위상 정렬 실행
    while (!q.empty()) {
        int node = q.front();
        q.pop();
        result.push_back(node); // 정렬된 결과에 추가

        for (int neighbor : graph[node]) {
            inDegree[neighbor]--; // 연결된 노드의 진입 차수 감소
            if (inDegree[neighbor] == 0) {
                q.push(neighbor); // 더 이상 선수 과목이 없는 경우 큐에 추가
            }
        }
    }

    // 모든 과목을 처리하지 못했다면, 사이클이 존재함 (즉, 수강 불가능한 과목 존재)
    if (result.size() != numCourses) {
        return {};
    }

    return result;
}

// 메인 함수
int main() {
    int numCourses = 6;
    vector<vector<int>> prerequisites = {{5, 2}, {5, 0}, {4, 0}, {4, 1}, {2, 3}, {3, 1}};

    vector<int> order = topologicalSort(numCourses, prerequisites);

    if (order.empty()) {
        cout << "사이클이 존재하여 위상 정렬이 불가능합니다!" << endl;
    } else {
        cout << "위상 정렬 결과 (작업 순서): ";
        for (int course : order) {
            cout << course << " ";
        }
        cout << endl;
    }

    return 0;
}
```

---

## **🔹 실행 결과**
위의 예제에서 `numCourses = 6`이고,  
**선수 조건이 있는 과목 목록**은:
```plaintext
5번 과목을 듣기 위해서는 2번과 0번을 먼저 수강해야 함.
4번 과목을 듣기 위해서는 0번과 1번을 먼저 수강해야 함.
2번 과목을 듣기 위해서는 3번을 먼저 수강해야 함.
3번 과목을 듣기 위해서는 1번을 먼저 수강해야 함.
```
이 경우, 가능한 **위상 정렬 결과**는 다음과 같을 수 있습니다:
```plaintext
위상 정렬 결과 (작업 순서): 0 1 3 2 4 5
```
하지만 위상 정렬은 유일하지 않으므로 다른 순서도 가능합니다.  
예를 들어:  
```plaintext
위상 정렬 결과: 1 0 3 2 4 5
```
이런 방식도 가능할 수 있습니다.

---

## **🔹 코드 설명**
1. **그래프 생성 및 진입 차수 계산**
   - 주어진 선수 과목을 기반으로 방향 그래프를 구성합니다.
   - `inDegree` 배열을 사용하여 **각 노드(과목)의 진입 차수(선수 과목 개수)**를 저장합니다.

2. **진입 차수가 0인 노드를 큐에 삽입**
   - 먼저 수강 가능한 과목을 큐에 넣습니다.

3. **큐에서 하나씩 꺼내면서 위상 정렬 수행**
   - 해당 노드(과목)를 `result` 리스트에 추가합니다.
   - 연결된 모든 노드(과목)의 진입 차수를 1씩 줄이고, **진입 차수가 0이 되면 큐에 추가**합니다.

4. **사이클 체크**
   - 모든 과목이 `result`에 들어가지 못하면, 사이클이 존재한다는 의미이므로 `[]`을 반환합니다.

---

## **📌 정리**
✅ **위상 정렬의 활용 사례**
- 작업 스케줄링 (예: 선수 과목 순서 결정)
- 소프트웨어 빌드 순서 결정
- 컴파일러에서 코드 의존성 분석
- 게임 개발에서 퀘스트 수행 순서 결정

✅ **시간 복잡도**  
- **O(V + E)** (V = 정점 수, E = 간선 수)  
  (BFS 기반이므로, 그래프의 모든 노드와 간선을 한 번씩 확인)

✅ **위상 정렬의 핵심**
1. **진입 차수(in-degree) 계산**
2. **진입 차수가 0인 노드부터 순차적으로 처리**
3. **모든 노드를 처리하면 위상 정렬 완료 (사이클 확인 포함)**

이제 위상 정렬을 실무에서도 잘 활용할 수 있겠죠? 😊

## **🔹 계수 정렬 (Counting Sort)란?**
계수 정렬은 **특정 범위 내의 정수들을 빠르게 정렬하는 알고리즘**입니다.  
특히 **정수 값이 많고 최대값이 크지 않은 경우** 매우 빠르게 동작합니다.  

✅ **시간 복잡도:** O(N + K) (N: 데이터 개수, K: 데이터의 최댓값)  
✅ **공간 복잡도:** O(K) (최댓값 크기만큼 추가 메모리 필요)  
✅ **비교 기반이 아님** → 정렬할 때 **비교 연산을 하지 않음!**

---

## **📌 계수 정렬의 활용 사례**
1️⃣ **시험 점수 정렬**  
   - 학생들의 시험 점수(0~100)를 빠르게 정렬할 때 사용  
   - 점수가 최대 100점이므로, **크기가 작은 정수 범위에 적합**  

2️⃣ **선거 개표 시스템**  
   - 특정 후보의 투표 수를 빠르게 집계 가능  
   - 후보자가 100명 이하라면 계수 정렬이 매우 효과적  

3️⃣ **게임 랭킹 시스템**  
   - 플레이어 점수를 빠르게 정렬  
   - 특정한 **범위 내의 점수**라면, 계수 정렬이 효과적  

---

## **🔹 C++ 예제 1: 학생 시험 점수 정렬**
학생들의 점수가 0~100 사이일 때, 이를 계수 정렬로 정렬하는 코드입니다.

```cpp
#include <iostream>
#include <vector>

using namespace std;

void countingSort(vector<int>& arr, int maxValue) {
    vector<int> count(maxValue + 1, 0);  // 점수 범위 (0~100)
    
    // 1️⃣ 각 숫자의 빈도수를 계산
    for (int num : arr) {
        count[num]++;
    }

    // 2️⃣ 정렬된 결과를 다시 arr에 채우기
    int index = 0;
    for (int i = 0; i <= maxValue; i++) {
        while (count[i] > 0) {
            arr[index++] = i;
            count[i]--;
        }
    }
}

int main() {
    vector<int> scores = {85, 92, 100, 67, 85, 92, 89, 100, 92, 67};
    int maxScore = 100;  // 점수의 최댓값

    countingSort(scores, maxScore);

    cout << "정렬된 점수: ";
    for (int score : scores) {
        cout << score << " ";
    }
    cout << endl;

    return 0;
}
```

### **✅ 실행 결과**
```plaintext
정렬된 점수: 67 67 85 85 89 92 92 92 100 100
```

---

## **🔹 C++ 예제 2: 선거 개표 시스템 (후보별 득표수 정렬)**
각 후보자에게 들어온 **투표 수를 집계하고, 투표 수가 높은 순으로 정렬하는 코드**입니다.

```cpp
#include <iostream>
#include <vector>

using namespace std;

void countingSortVotes(vector<int>& votes, int maxCandidate) {
    vector<int> count(maxCandidate + 1, 0);  // 후보자 번호 범위 (0 ~ maxCandidate)

    // 1️⃣ 각 후보자의 득표수 계산
    for (int vote : votes) {
        count[vote]++;
    }

    // 2️⃣ 정렬된 결과 출력 (투표 수가 많은 후보부터 출력)
    cout << "후보 번호별 득표 수 (많은 순):\n";
    for (int i = maxCandidate; i >= 0; i--) {
        if (count[i] > 0) {
            cout << "후보 " << i << ": " << count[i] << "표\n";
        }
    }
}

int main() {
    vector<int> votes = {2, 3, 3, 5, 2, 3, 1, 5, 5, 5, 3, 2, 1, 3, 5, 2};
    int maxCandidate = 5;  // 후보자 번호 최대값 (1~5번 후보 존재)

    countingSortVotes(votes, maxCandidate);

    return 0;
}
```

### **✅ 실행 결과**
```plaintext
후보 번호별 득표 수 (많은 순):
후보 5: 5표
후보 3: 5표
후보 2: 4표
후보 1: 2표
```
**👉 특정 숫자의 개수를 빠르게 집계**하는 데 계수 정렬이 매우 효과적입니다!

---

## **🔹 계수 정렬이 효과적인 경우와 비효율적인 경우**
### ✅ **효과적인 경우**
- 정수 데이터의 값 범위가 크지 않은 경우 (예: 0~100)
- 같은 값이 여러 번 등장하는 경우 (빈도수를 기반으로 정렬)
- 데이터 크기(N)가 매우 크지만, 값의 범위(K)는 작을 때

### ❌ **비효율적인 경우**
- 값의 범위가 너무 큰 경우 (예: 0~1,000,000,000)
- 소수점이 있는 실수 데이터 (계수 정렬은 정수 전용)
- 비교 기반 정렬(퀵 정렬, 병합 정렬)이 더 적절한 경우

---

## **🔹 정리**
1️⃣ 계수 정렬은 **정수 값 범위가 제한된 경우** 매우 빠르고 효율적인 정렬 방법이다.  
2️⃣ **시간 복잡도는 O(N + K)이며, 매우 빠르다** (하지만 추가적인 메모리 사용 필요).  
3️⃣ 시험 점수 정렬, 선거 개표, 게임 점수 정렬 등에서 **빠른 집계 및 정렬**에 유용하다.  
4️⃣ **범위가 너무 크거나 실수가 포함된 경우에는 적합하지 않음** (퀵 정렬이나 병합 정렬이 더 적합).  

이제 계수 정렬을 적절한 상황에서 활용할 수 있겠죠? 😊

