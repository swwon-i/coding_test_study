# 11. 그래프
## 11-1 그래프의 개념
노드와 간선을 이용한 비선형 데이터 구조
### 그래프 용어 정리
간선, 가중치, 정점
### 그래프의 특징과 종류
방향성, 가중치, 순환 특성에 따라 종류를 구분
### 흐름을 표현하는 방향성
방향 그래프, 무방향 그래프
### 흐름의 정도를 표현하는 가중치
데이터의 양 가중치, 가중치 그래프
### 시작과 끝의 연결 여부를 보는 순환
순환 그래프, 비순환 그래프
## 그래프 구현
노드, 간선, 방향, 가중치
### 인접 행렬 그래프 표현
### 인접 리스트 그래프 표현
[v, w]로 묶어서 vector에 넣기
```c++
#include <iostream>
#include <vector>
using namespace std;

struct nodeInfo
{
	int V;
	int W;
};

vector<vector<nodeInfo>> adjList;

void addEdge(int u, int v, int w)
{
	adjList[u].push_back({v, w});
}

void printAdjList()
{
	for (int i = 0; i < adjList.size(); ++i)
	{
		cout << "Node " << i << ":";
		for (const auto& node : adjList[i])
		{
			cout << " -> (V: " << node.V << ", W: " << node.W << ")";
		}
		cout << endl;
	}
}

int main()
{
	int N = 5;
	adjList.resize(N);

	addEdge(1, 2, 3);
	addEdge(2, 1, 6);
	addEdge(2, 3, 5);
	addEdge(3, 2, 1);
	addEdge(3, 4, 13);
	addEdge(4, 4, 9);
	addEdge(4, 1, 42);

	printAdjList();

	return 0;
}
```

### 인접 행렬과 인접 리스트의 장단점
#### 인접 행렬의 장단점
V X V
O(1) 시간 복잡도가 O(1)
#### 인접 리스트의 장단점
간선의 수를 E
O(E)
그래프의 모든 간선을 찾는 경우 시간 복잡도
O(V + E)

## 11-2 그래프 탐색
더 이상 탐색할 노드가 없을 때까지(깊이 우선 탐색)
현재 위치에서 가장 가까운 노드부터 모두 방문하고 다음 노드로 넘어감(너비 우선 탐색)
### 깊이 우선 탐색
시작 노드부터 탐색을 시작하여 간선을 따라 최대 깊이 노드까지 이동
1. 스택이 비었는지 확인 비어있으면 모든 노드를 방문
2. 스택에서 노드를 팝함. 팝한 원소는 최근에 스택에 푸시한 노드
3. 팝한 노드의 방문 여부를 확인. 아직 방문하지 않았다면 노드를 방문 처리
4. 아직 방문하지 않은 노드를 스택에 푸시
#### 스택을 활용한 깊이 우선 탐색
### 재귀 함수를 활용한 깊이 우선 탐색
### 너비 우선 탐색
#### 큐를 활용한 너비 우선 탐색
### 깊이 우선 탐색과 너비 우선 탐색 비교
깊이 우선 탐색은 깊게 탐색 후 되돌아오는 특성이 있고, 너비 우선 탐색은 시작 노드에서 인접한 노드부터 방문하는 특성을 가집니다.
#### 깊이 탐색 후 되돌아오는 깊이 우선 탐색
최단 경로를 찾는 문제가 아니면 깊이 우선 탐색을 우선 고려해보는 것이 좋음
모든 가능한 해를 찾는 백트래킹 알고리즘을 구현할 때나 그래프의 사이클을 감지해야 하는 경우 활용할 수 있습니다.
#### 최단 경로를 보장하는 너비 우선 탐색
시작 노드로부터 최단 경로임을 보장합니다.

## 11-3 그래프 최단 경로 구하기
### 다익스트라 알고리즘
### 벨만-포드 알고리즘
(음의 가중치 고려)
### 플로이드-워셜 알고리즘
모든 노드에서의 최단 경로를 모두 구하는 알고리즘


### ✅ `std::sort` vs `std::priority_queue` 비교 정리

비교 기준

`std::sort`

`std::priority_queue`

**정렬 방식**

전체 정렬 (O(N log N))

힙을 유지하며 삽입/삭제 (O(log N))

**비교 함수 호출 위치**

정렬 과정에서 원소를 비교할 때

삽입 및 삭제 시 힙 속성 유지 과정에서

**비교 함수(`cmp(a, b)`)의 의미**

`true`이면 `a`가 `b`보다 앞에 와야 함

`true`이면 `b`의 우선순위가 높음 (즉, `a`가 아래로 가야 함)

**`a, b`의 역할**

`a`: 왼쪽 원소, `b`: 오른쪽 원소

`a`: 부모 노드, `b`: 자식 노드 (또는 새로운 노드)

**오름차순 정렬을 위한 비교 함수**

`a < b`

`a > b`

**최대 힙 (내림차순) 비교 함수**

`a > b`

`a < b`

✅ **핵심 정리:**

-   `std::sort`는 `true`일 때 `a`가 `b`보다 앞에 와야 하지만,
-   `priority_queue`는 `true`일 때 `b`가 `a`보다 우선순위가 높음(힙 유지 과정에서 참이면 변경 없음).

---
좋은 질문이에요! 최단 거리를 갱신하는 방식은 **벨만-포드 알고리즘**의 핵심인데요, 좀 더 자세히 설명해드릴게요.

### 핵심 아이디어:
최단 거리를 갱신하는 방법은 **각 정점에서 연결된 다른 정점으로 가는 경로를 "업데이트"하는** 방식이에요. 이걸 반복하는 이유는 그래프의 간선(엣지)을 여러 번 확인하면서 점차적으로 정확한 최단 거리를 찾는 과정이에요.

### 예시로 설명:
우리가 어떤 정점에서 다른 정점으로 가는 **최단 거리**를 구한다고 해봅시다. 처음에는 출발 정점의 거리는 `0`이고, 다른 모든 정점의 거리는 **무한대(INF)** 로 설정해놓습니다.

#### 1. 처음 상태 (출발 정점 `A`):
- A → 0, B → INF, C → INF, D → INF
- A에서 다른 정점으로 가는 방법이 여러 가지일 수 있죠.

#### 2. 첫 번째 반복 (1번 확인):
그래프에서 간선을 하나씩 확인하면서, 가는 경로의 **거리가 더 짧으면 갱신**합니다.
예를 들어, `A -> B`라는 간선이 있고 가중치가 `3`이라면, `A`에서 `B`로 가는 최단 거리는 3으로 갱신됩니다.

이런 방식으로 첫 번째 반복이 끝나면:
- A → 0, B → 3, C → INF, D → INF

#### 3. 두 번째 반복 (2번 확인):
다시 한 번 그래프의 간선들을 확인하면서 최단 거리를 갱신합니다. 예를 들어, `B -> C`로 가는 간선이 있고 가중치가 `2`라면, `B`에서 `C`로 가는 최단 거리는 `B`에서 `C`까지 가는 경로(`3 + 2 = 5`)로 갱신됩니다.

- A → 0, B → 3, C → 5, D → INF

#### 4. 이렇게 반복하는 이유:
왜 **최대 `num_vertices - 1`번** 반복하냐면, 그래프에서 최단 경로를 찾으려면 간선이 최대 `num_vertices - 1`번 지나갈 수 있기 때문이에요. 예를 들어, 4개의 정점이 있으면, 가장 긴 경로는 **3번의 간선**을 지나야 할 수도 있기 때문에 3번까지 갱신할 수 있도록 반복하는 거예요.

### 5. 반복을 계속하면서 갱신되는 모습:
이 과정을 여러 번 반복하면서, 각 정점까지의 최단 거리가 점차적으로 갱신됩니다. **갱신을 계속하는 이유**는 **경로를 찾을 때마다 더 빠르고 짧은 길을 발견**하기 때문이에요.

### 6. 왜 "계속 도는" 방식일까요?
그 이유는 **단계적으로 점점 더 최단 경로를 찾기** 때문입니다. 그래프에서 간선 하나하나가 여러 번 확인되면서 점차적으로 최단 거리가 갱신되는 과정이에요. "계속 도는 것"은 바로 이 갱신 과정이므로, 최단 거리가 정확하게 나올 때까지 반복해야 합니다.

### 간단히 말하자면:
- 각 간선은 출발점에서 도착점까지의 **최단 거리**를 **업데이트**합니다.
- 여러 번 반복하여 정확한 최단 거리를 찾습니다. (최대 `num_vertices - 1`번 반복)
- **그 과정을 반복하면서 점점 더 빠르고 정확한 최단 경로를 찾아갑니다.**

### 한 번 더 예시로 풀어볼게요:
- 정점 A, B, C가 있고, 간선은 A → B(3), B → C(2), A → C(10)이라면, 처음에 A → C의 거리는 10입니다. 하지만 `A → B → C`를 거쳐가면 5로 더 짧은 경로가 있다는 것을 **반복하면서 발견**합니다.

이렇게 반복하는 이유가 바로 **최단 거리 갱신**이에요!

